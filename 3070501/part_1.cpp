#include <iostream>
using namespace std;
/*三维数组 a[x][y][z]：
 *x 表示深度：三维数组有 x 个二维平面 - 第 i 个平面：存储从 a[i][0][0] 到 a[i][y-1][z-1]
 *y 表示行数：每个二维平面有 y 行。
 *z 表示列数：每一行有 z 个元素。*/
/*如果我们将整个三维数组视为一维数组，其索引的计算公式是：
 *一维索引=i×(y×z)+j×z+k
*/
/*例：3个平面 × 4行 × 5列 的三维数组
a[0][0]:  0, 1, 2, 3, 4
a[0][1]:  5, 6, 7, 8, 9
a[0][2]: 10,11,12,13,14
a[0][3]: 15,16,17,18,19

a[1][0]: 20,21,22,23,24
a[1][1]: 25,26,27,28,29
a[1][2]: 30,31,32,33,34
a[1][3]: 35,36,37,38,39

a[2][0]: 40,41,42,43,44
a[2][1]: 45,46,47,48,49
a[2][2]: 50,51,52,53,54
a[2][3]: 55,56,57,58,59
在内存中的连续存储顺序为：0, 1, 2, ..., 59
 */
/*第一步：data + i * y * z - 通过跳过前 i 个二维平面来定位第 i 个平面的起始地址

假设 i = 1，我们要访问第 1 个二维平面 a[1]：

每个二维平面有 y * z = 4 × 5 = 20 个元素。
第 1 个二维平面的起始地址偏移为 1 × 20 = 20。
因此，data + 1 * 20 就指向第 1 个二维平面的首地址，即 a[1][0][0] 的地址。*/
/*第二步：row_data + j * z - 通过跳过前 j 行来定位第 j 行的首地址

假设我们在第 1 个二维平面中要访问第 2 行 a[1][2]：

每行有 z = 5 个元素。
第 2 行的起始地址偏移为 2 × 5 = 10。
从 a[1][0][0] 开始偏移 10 个元素，地址就指向 a[1][2][0]。*/
/*a[1][2][3]
逐层计算：

a[1]：通过 data + 1 * 20，找到 a[1][0][0] 的地址。
a[1][2]：通过 row_data + 2 * 5，找到 a[1][2][0] 的地址。
a[1][2][3]：直接访问偏移量为 3 的位置，结果为 33。*/
// 在此处补充你的代码
template<typename T>
class CArray3D
{
private:
    T* data; // 存储三维数组数据的指针
    int x, y, z; // 三维数组的维度

    // 辅助类，用于模拟二维数组
    class CArray2D
    {
    private:
        T* row_data; // 指向对应二维平面数据的指针 - 平面首地址
        int z; // 每行的列数
    public:
        CArray2D(T* data, int z) : row_data(data), z(z) {}

        T* operator[](int j)
        {
            // 用于选取二维平面中的某一行
            //          row_data 是一个指针，指向某个二维平面的起始地址（如 a[i][0][0]）
            //          j * z：
            //          每行有 z 个元素。
            //          如果我们需要跳过 j 行，总共需要跳过 j * z 个元素。
            //          因此，row_data + j * z 就是第 j 行的首地址（即 a[i][j][0] 的地址）
            return row_data + j * z; // 返回（第 i 个二维平面中）第j行的首地址（行首指针）
        }
    };

public:
    CArray3D(int x, int y, int z) : x(x), y(y), z(z)
    {
        data = new T[x * y * z]; // 申请连续内存
    }

    ~CArray3D()
    {
        delete[] data; // 释放内存
    }

    CArray2D operator[](int i)
    {
        //用于选取某一二维平面
        //      data 是一个指针，指向三维数组的起始地址，即 a[0][0][0]
        //      i * y * z：
        //      每个二维平面有 y * z 个元素。
        //      如果我们需要跳过 i 个二维平面，总共需要跳过 i * y * z 个元素。
        //      因此，data + i * y * z 就是指向第 i 个二维平面起始地址（即 a[i][0][0] 的地址）
        return CArray2D(data + i * y * z, z); // a[i] 的结果是一个 CArray2D 对象 - 返回 CArray3D对象 对应的第 i 个二维平面
    } //再对它调用 [j]，会执行 CArray2D 类中的 operator[]
};

int main()
{
    CArray3D<int> a(3, 4, 5);
    int No = 0;
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 4; ++j)
            for (int k = 0; k < 5; ++k)
                a[i][j][k] = No++;
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 4; ++j)
            for (int k = 0; k < 5; ++k)
                cout << a[i][j][k] << ","; //返回第 i 个二维平面中第 j 行第 k 列的元素值
    return 0;
}
