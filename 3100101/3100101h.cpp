//
// Created by Ruohao L. on 01/12/2024.
//
#include <iostream>
#include <cstdio>
using namespace std;

int main()
{
    int t; // 数据组数
    cin >> t;
    while (t--)
    {
        unsigned int n;
        int i, j;
        cin >> n >> i >> j;

        // 初始化 k 为 0
        unsigned int k = 0;

        // 设置第 i 位和 n 的第 i 位相同
        // 利用位操作提取 n 的第 i 位：(n >> i) & 1
        k |= ((n >> i) & 1) << i;

        // 设置第 j 位和 n 的第 j 位相反
        // 同样方法提取 n 的第 j 位：(n >> j) & 1
        // 后一个 & 1 将多余的高位清零，得到 0 或 1
        // k |= (~((n >> j) & 1) & 1) << j;
        // 或避免显式取反：
        k |= (1 ^ ((n >> j) & 1)) << j;

        // 设置 i 和 j 之间的位为 1
        // 设置一段位为 1：((1 << len) - 1) << offset
        /*思路：
         * 第一步：先构造一个单个的 1 位，位于第 j-i-1 位（为了之后让[0,j-i-1)位都为0）
         * 假设 j = 5，i = 2，则 j - i - 1 = 2
         * 计算 1 << 2：将 1 左移 2 位，结果是：0100（即十进制的 4）
         * 此时结果是一个二进制数，只在第 j-i-1 位为 1，其余位为 0
         * 第二步：为了让0100变成0011，我们减去1 - 在位操作中，减去 1 的作用是将从最高有效位开始的所有低位变成 1
         * 至此，我们生成了一个长度为 j - i - 1 的连续 1 序列（这个长度恰好是(i,j)的长度）
         * 第三步：左移 (i + 1) - 将上述生成的连续 1 序列移到正确的位置，即移动到从第 i+1 位开始
         * 现在，0001 1000 是一个二进制数，只在 i+1 到 j-1 位之间为 1，其余位为 0
         * 第四步：将生成的结果与 k 进行按位或操作，设置对应的位
         */
        k |= ((1 << (j - i - 1)) - 1) << (i + 1);

        // 输出 k 的十六进制表示
        printf("%X\n", k);
    }
    return 0;
}
